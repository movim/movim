<?php
/*
 * SPDX-FileCopyrightText: 2010 Jaussoin TimothÃ©e
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */

namespace Movim\Daemon;

use Ratchet\MessageComponentInterface;
use Ratchet\ConnectionInterface;
use React\EventLoop\LoopInterface;

use Dflydev\FigCookies\Cookies;

use Movim\Daemon\Session;

use App\Session as DBSession;
use App\EncryptedPassword;
use App\PushSubscription;
use App\Info;
use Minishlink\WebPush\VAPID;
use Movim\Template\Partial;
use React\Promise\PromiseInterface;
use WyriHaximus\React\Cron;
use WyriHaximus\React\Cron\Action;

use function React\Promise\resolve;

class Core implements MessageComponentInterface
{
    const WORKER_MAX_SESSIONS = 4;
    public $workers = [];
    private $key; // Random key generated by the daemon to authenticate the internal Websockets

    public LoopInterface $loop;
    public $baseuri;

    public function __construct(LoopInterface $loop, $baseuri)
    {
        $this->key = \generateKey(32);

        $this->generateWebServerConfig(config('daemon.port'));

        $this->loop    = $loop;
        $this->baseuri = $baseuri;

        DBSession::whereNotNull('id')->delete();

        if (file_exists(API_SOCKET)) unlink(API_SOCKET);
        if (file_exists(AVATAR_HANDLER_SOCKET)) unlink(AVATAR_HANDLER_SOCKET);
        if (file_exists(PUSHER_SOCKET)) unlink(PUSHER_SOCKET);
        if (file_exists(RESOLVER_SOCKET)) unlink(RESOLVER_SOCKET);
        if (file_exists(TEMPLATER_SOCKET)) unlink(TEMPLATER_SOCKET);

        array_map('unlink', array_merge(
            glob(PUBLIC_CACHE_PATH . '*.css'),
            glob(PUBLIC_CACHE_PATH . '*.js')
        ));

        $this->registerCleaner();

        // Generate Push Notification
        if (!file_exists(CACHE_PATH . 'vapid_keys.json')) {
            echo colorize("Generate and store the Push Notification VAPID keys", 'green') . "\n";
            $keyset = VAPID::createVapidKeys();
            file_put_contents(CACHE_PATH . 'vapid_keys.json', json_encode($keyset));
        }
    }

    public function dumpSessionsTree(): string
    {
        $tree = [];

        foreach ($this->workers as $worker) {
            $tree[$worker->id] = [];

            foreach ($worker->getSessions() as $session) {
                $tree[$worker->id][$session->sid] = [
                    'clients' => $session->countClients(),
                    'registered' => $session->registered,
                    'started' => $session->started,
                ];
            }
        }

        return json_encode($tree);
    }

    public function getKey(): string
    {
        return $this->key;
    }

    public function generateWebServerConfig($port)
    {
        echo
        "\n" .
            "--- " . colorize("Server Configuration - Apache", 'purple') . " ---" .
            "\n";
        echo colorize("Enable the Secure WebSocket to WebSocket tunneling", 'yellow') . "\n# a2enmod proxy_wstunnel \n";
        echo colorize("Add this in your configuration file (default-ssl.conf)", 'yellow') . "\nProxyPass /ws/ ws://127.0.0.1:{$port}/\n";

        echo
        "\n" .
            "--- " . colorize("Server Configuration - nginx", 'purple') . " ---" .
            "\n";
        echo colorize("Add this in your configuration file", 'yellow') . "\n";
        echo "location /ws/ {
    proxy_pass http://127.0.0.1:{$port}/;
    proxy_http_version 1.1;
    proxy_set_header Upgrade \$http_upgrade;
    proxy_set_header Connection \"Upgrade\";
    proxy_set_header Host \$host;
    proxy_set_header X-Real-IP \$remote_addr;
    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto https;
    proxy_redirect off;
    proxy_read_timeout 1800s;
    proxy_send_timeout 1800s;
}
";

        echo
        "\n" .
            "--- " . colorize("Server Configuration - Caddy", 'purple') . " ---" .
            "\n";
        echo colorize("Add this in your configuration file", 'yellow') . "\nhandle /ws/* {
    reverse_proxy localhost:{$port}
}

";
    }

    public function onOpen(ConnectionInterface $connection)
    {
        if (!$this->isTrustedConnection($connection)) $connection->close();

        // WebSockets from the Browser
        $sid = $this->getCookieSid($connection);
        if ($sid != null) {
            // If the session exists we attach it
            foreach ($this->workers as $worker) {
                if ($worker->hasSession($sid)) {
                    $worker->attachSession($sid, $connection);
                    return;
                }
            }

            // If not we find an available worker and attach the session to it
            foreach ($this->workers as $worker) {
                if ($worker->countSessions() < Core::WORKER_MAX_SESSIONS) {
                    $worker->newSession($sid, $connection);
                    return;
                }
            }

            // If not we launch a new worker and attach the session
            $worker = new SessionsWorker($this->loop, $this->baseuri, $this->key);
            $this->workers[$worker->id] = $worker;
            $worker->newSession($sid, $connection);
        } elseif ($this->isTemplater($connection)) {
            echo colorize("Templater connected", 'green') . "\n";
        } else {
            // WebSocket from the linkers
            $wid = $this->getHeaderWid($connection);

            if ($wid != null && isset($this->workers[$wid])) {
                $this->workers[$wid]->attachInternal($connection);

                $obj = new \StdClass;
                $obj->func = 'started';
                $this->workers[$wid]->messageOut(json_encode($obj));
            }
        }
    }

    public function onMessage(ConnectionInterface $from, $message)
    {
        if ($this->isTemplater($from)) {
            $json = json_decode($message);
            $sid = $json->sid;
            if ($sid == null) return;

            $this->findSession($sid)?->messageOut(json_encode($json));
            return;
        }

        if ($json = json_decode($message)) {
            $cookieSid = $this->getCookieSid($from);

            if ($cookieSid && $session = $this->findSession($cookieSid)) {
                $json->sid = $cookieSid;
                $message = json_encode($json);
                $session->messageIn($message);
            } elseif (isset($json->sid)) {
                $sid = $json->sid;

                if ($sid != null && $session = $this->findSession($sid)) {
                    if (isset($json->logout)) {
                        $session->close();
                    } elseif (isset($json->registered)) {
                        $session->registered = true;
                    } elseif (isset($json->started)) {
                        $session->started = true;
                    } else {
                        $session->messageOut($message);
                    }
                }
            }
        }
    }

    public function onClose(ConnectionInterface $connection)
    {
        $sid = $this->getCookieSid($connection);

        if ($sid == null) return;

        $resolvedWorker = $resolvedSession = null;
        foreach ($this->workers as $worker) {
            if ($worker->hasSession($sid)) {
                $resolvedWorker = $worker;
                $resolvedSession = $worker->getSession($sid);
                break;
            }
        }

        if ($resolvedSession) {
            $resolvedSession->detach($this->loop, $connection);
            if ($resolvedSession->registered == false) {
                $resolvedWorker->closeSession($sid);
            }
        }

        if (
            $resolvedWorker &&
            ($resolvedWorker->countSessions() == 0 || $resolvedWorker->process == null)
        ) {
            $resolvedWorker->close();
            unset($this->workers[$resolvedWorker->id]);
        }
    }

    public function forceClose($sid)
    {
        foreach ($this->workers as $worker) {
            if ($worker->hasSession($sid)) {
                $worker->closeSession($sid);
            }
        }
    }

    public function findSession(string $sid): ?Session
    {
        foreach ($this->workers as $worker) {
            if ($worker->hasSession($sid)) {
                return $worker->getSession($sid);
            }
        }

        return null;
    }

    private function registerCleaner()
    {
        $this->loop->addPeriodicTimer(5, function () {
            foreach ($this->workers as $key => $worker) {
                if ($worker->countSessions() == 0) {
                    $worker->close();
                    unset($this->workers[$key]);
                }
            }

            $this->cleanupDBSessions();
        });

        $this->cleanupEncryptedPasswords();
        $this->cleanupPushSubscriptions();
        $this->cleanupInfos();
        $this->cleanupChatsCache();

        $this->loop->addPeriodicTimer(60 * 60 * 24, function () {
            $this->cleanupEncryptedPasswords();
            $this->cleanupPushSubscriptions();
            $this->cleanupInfos();
        });
    }

    /**
     * @desc Clear Chats items cache
     */
    private function cleanupChatsCache()
    {
        Cron::create(
            new Action(
                'cleanCache',
                0.1,
                '1 0 * * *',
                function (): PromiseInterface {
                    foreach (
                        glob(
                            CACHE_PATH . '*__chats_item_*' . Partial::EXTENSION,
                            GLOB_NOSORT
                        ) as $path
                    ) {
                        @unlink($path);
                    }

                    return resolve(true);
                }
            )
        );
    }

    /**
     * @desc Delete infos that were pulled after two months, they will be refreshed if required
     */
    private function cleanupInfos()
    {
        Info::where('updated_at', '<', date(MOVIM_SQL_DATE, time() - (60 * 60 * 24 * 30 * 2)))
            ->delete();
    }

    private function cleanupDBSessions()
    {
        DBSession::where('active', false)
            ->where('created_at', '<', date(MOVIM_SQL_DATE, time() - 60))
            ->delete();
    }

    /**
     * @desc Delete push subscriptions without activity after a month
     */
    private function cleanupPushSubscriptions()
    {
        PushSubscription::where('activity_at', '<', date(MOVIM_SQL_DATE, time() - (60 * 60 * 24 * 30)))
            ->delete();
    }

    /**
     * @desc Delete encrypted passwords after 7 days without update
     */
    private function cleanupEncryptedPasswords()
    {
        EncryptedPassword::where('updated_at', '<', date(MOVIM_SQL_DATE, time() - (60 * 60 * 24 * 7)))
            ->delete();
    }

    public function onError(ConnectionInterface $connection, \Exception $e)
    {
        echo "An error has occurred: {$e->getMessage()}\n";
    }

    public function getStartedSessions(): array
    {
        $sessions = [];
        foreach ($this->workers as $worker) {
            $sessions += array_map(
                fn($session) => $session->started,
                $worker->getSessions()
            );
        }

        return $sessions;
    }

    private function getCookieSid(ConnectionInterface $connection)
    {
        $cookies = Cookies::fromRequest($connection->httpRequest);

        return $cookies->get('MOVIM_SESSION_ID')
            ? $cookies->get('MOVIM_SESSION_ID')->getValue()
            : null;
    }

    public function isTemplater(ConnectionInterface $connection)
    {
        return ($connection->httpRequest->hasHeader('MOVIM_TEMPLATER'));
    }

    private function getHeaderWid(ConnectionInterface $connection)
    {
        return ($connection->httpRequest->hasHeader('MOVIM_WORKER_ID'))
            ? $connection->httpRequest->getHeader('MOVIM_WORKER_ID')[0]
            : null;
    }

    private function isTrustedConnection(ConnectionInterface $connection): bool
    {
        $daemonKeyHeader = $connection->httpRequest->getHeader('MOVIM_DAEMON_KEY');
        $secFetchSiteHeader = $connection->httpRequest->getHeader('Sec-Fetch-Site');

        $sameOrigin = (is_array($secFetchSiteHeader) && !empty($secFetchSiteHeader))
            ? $secFetchSiteHeader[0] == 'same-origin'
            : parse_url($connection->httpRequest->getHeader('Origin')[0], PHP_URL_HOST) == parse_url($this->baseuri, PHP_URL_HOST);

        return (is_array($daemonKeyHeader) && !empty($daemonKeyHeader) && $daemonKeyHeader[0] === $this->key)
            || $sameOrigin;
    }
}
